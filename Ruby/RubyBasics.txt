
--> Ruby Version Manager (RVM)

RVM is a command-line tool which allows you to easily install, manage, and work with multiple ruby environments from interpreters to sets of gems.

* Installing Rvm:-

steps:-
curl -sSL https://rvm.io/mpapis.asc | gpg --import -
curl -sSL https://rvm.io/pkuczynski.asc | gpg --import -
curl -sSL https://get.rvm.io | bash -s stable
rvm --version

beryl@beryl-HP-ProBook-6460b:~$ rvm --version
rvm 1.29.12 (latest) by Michal Papis, Piotr Kuczynski, Wayne E. Seguin [https://rvm.io]


* installing Ruby latest version:-

--> rvm install ruby
--> rvm install 2.7

-->beryl@beryl-HP-ProBook-6460b:~$ rvm list
=> ruby-2.6.6 [ x86_64 ]
   ruby-2.7.2 [ x86_64 ]
 * ruby-3.0.0 [ x86_64 ]

# => - current
# =* - current && default
#  * - default


** rvm use command :-

beryl@beryl-HP-ProBook-6460b:~$ rvm use 3.0
Using /home/beryl/.rvm/gems/ruby-3.0.0

beryl@beryl-HP-ProBook-6460b:~$ rvm use 2.7.2
Using /home/beryl/.rvm/gems/ruby-2.7.2


* set any version of ruby as default version :-

beryl@beryl-HP-ProBook-6460b:~$ rvm use 2.7.2 --default
Using /home/beryl/.rvm/gems/ruby-2.7.2
beryl@beryl-HP-ProBook-6460b:~$ rvm list
   ruby-2.6.6 [ x86_64 ]
=* ruby-2.7.2 [ x86_64 ]
   ruby-3.0.0 [ x86_64 ]


 ** rvm help command
 beryl@beryl-HP-ProBook-6460b:~$ rvm help

  for example:

    rvm list                # list installed interpreters 
    rvm list known          # list available interpreters
    rvm install <version>   # install ruby interpreter
    rvm use <version>       # switch to specified ruby interpreter
    rvm remove <version>    # remove ruby interpreter (alias: delete)
    rvm get <version>       # upgrade rvm: stable, master

ruby installation
      fetch                   # download binary or sources for selected ruby version
      install                 # install ruby interpreter
      list                    # show currently installed ruby interpreters
      list known              # list available interpreters
      mount                   # install ruby from external locations
      patchset                # tools related to managing ruby patchsets
      pkg                     # install a dependency package
      reinstall               # reinstall ruby and run gem pristine on all gems
      remove                  # remove ruby and downloaded sources (alias: delete)
      requirements            # installs dependencies for building ruby
      uninstall               # uninstall ruby, keeping it's sources
      upgrade                 # upgrade to another ruby version, migrating gems

  running different ruby versions
      current                 # print current ruby version and name of used gemsets
      do                      # runs a command against specified and/or all rubies
      gemdir                  # display path to current gem directory ($GEM_HOME)
      use <version>           # switch to given (and already installed) ruby version
      use default             # switch to default ruby, or system if none is set
      use system              # switch to system ruby
      wrapper                 # creates wrapper executables for a given ruby & gemset


                                                      =====> Ruby Basics <====


-> Ruby is a dynamic, open source, object oriented and reflective programming language. Ruby is considered similar to Perl and Smalltalk programming languages. It runs on all types of platforms like Windows, Mac OS and all versions of UNIX.

-> It is fully object oriented programming language. Everything is an object in Ruby. Each and every code has their properties and actions. Here properties refer to variables and actions refer to methods.

-> Ruby is considered to follow the principle of POLA (principle of least astonishment). It means that the language behaves in such a way to minimize the confusion for experienced users.


* Let us write a simple program in ruby. All ruby files will have extension .rb So, put the following source code in a test.rb file.

  puts "Hello Rubby i am krishan sorout"
output:--
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
Hello ruby i am krishan sorout 

* Whitespace in Ruby Program

Whitespace characters such as spaces and tabs are generally ignored in Ruby code, except when they appear in strings. Sometimes, however, they are used to interpret ambiguous statements. Interpretations of this sort produce warnings when the -w option is enabled.
Example:-

a + b is interpreted as a+b ( Here a is a local variable)
a  +b is interpreted as a(+b) ( Here a is a method call)
  
 ** Line Endings in Ruby Program

Ruby interprets semicolons and newline characters as the ending of a statement. However, if Ruby encounters operators, such as +, −, or backslash at the end of a line, they indicate the continuation of a statement.

** Ruby Identifiers

Identifiers are names of variables, constants, and methods. Ruby identifiers are case sensitive. It means Ram and RAM are two different identifiers in Ruby.

Ruby identifier names may consist of alphanumeric characters and the underscore character ( _ ).

** Here Document in Ruby

"Here Document" refers to build strings from multiple lines. Following a << you can specify a string or an identifier to terminate the string literal, and all lines following the current line up to the terminator are the value of the string.

If the terminator is quoted, the type of quotes determines the type of the line-oriented string literal. Notice there must be no space between << and the terminator.

Here are different examples −


print <<EOF
   This is the first way of creating
   here document ie. multiple line string.
EOF

print <<"EOF";                # same as above
   This is the second way of creating
   here document ie. multiple line string.
EOF

print <<`EOC`                 # execute commands
	echo hi there
	echo lo there
EOC

print <<"foo", <<"bar"  # you can stack them
	I said foo.
foo
	I said bar.
bar

** Ruby BEGIN Statement
Syntax:-
puts "This line is not printed first"
BEGIN {
puts "this line always print first"
}

output:-- beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
this line always print first
This line is not printed first

** Ruby end statement:- 

END {
    puts "this line always printed in last"
}

puts "This line is not printed first"
BEGIN {
puts "this line always print first"
}

output:--
this line always print first
This line is not printed first
this line always printed in last

* Ruby Comments
-> multiple line comments

=begin
 this is a comment
 hii this is another way
 of multiple line comments
=end
-> single line comment in statement

puts "This line is not printed first"
BEGIN {
puts "this line always print first" # this is a comment
}
-> Another way of multiple line comment:-
# this is a comment
# this is a comment


**** Ruby - Classes and Objects:--

An object-oriented program involves classes and objects. A class is the blueprint from which individual objects are created. In object-oriented terms, we say that your bicycle is an instance of the class of objects known as bicycles.

** Defining a Class in Ruby:-

A class in Ruby always starts with the keyword class followed by the name of the class. The name should always be in initial capitals. The class Customer can be displayed as −

class Customer
end

You terminate a class by using the keyword end. All the data members in the class are between the class definition and the end keyword.

** Creating Objects in Ruby using new Method:-

cust1 = Customer. new
cust2 = Customer. new

**Custom Method to Create Ruby Objects:--

class Customer
   @@no_of_customers = 0
   def initialize(id, name, addr)
      @cust_id = id
      @cust_name = name
      @cust_addr = addr
   end
end

cust1 = Customer.new("1", "John", "Wisdom Apartments, Ludhiya")
cust2 = Customer.new("2", "Poul", "New Empire road, Khandala")

** variables:- 

* Global variable :-
Global variables begin with $. Uninitialized global variables have the value nil and produce warnings with the -w option.

$globalvar=10
$var2=100
class Test 
    def check
        puts "global variable in class 1 is #$globalvar"
    end
end
obj1=Test.new
obj1.check        
class Test1
    def check1
        puts "this is second claas and global variable is #$var2"
    end
end
obj2=Test1.new
obj2.check1        

output:--
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
global variable in class 1 is 10
this is second claas and global variable is 100

* Ruby Instance Variables:-
Instance variables begin with @. Uninitialized instance variables have the value nil and produce warnings with the -w option.

class Test 
    def initialize(id,name,addr)
        @id=id
        @name=name
        @addr=addr

    end 
    def details()
        puts "The id is #@id"
        puts "Name is #@name"
        puts "And the address is #@addr" 
    end
end

obj1=Test.new("1","krishan","hodal")
obj2=Test.new("2","mohit","palwal")
obj1.details()
obj2.details()

output:--
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
The id is 1
Name is krishan
And the address is hodal
The id is 2
Name is mohit
And the address is palwal


*Ruby Class Variables

Class variables begin with @@ and must be initialized before they can be used in method definitions.

class Test 
    @@classvar=0
    def initialize(id,name,addr)
        @id=id
        @name=name
        @addr=addr

    end 
    def details()
        puts "The id is #@id"
        puts "Name is #@name"
        puts "And the address is #@addr" 
    end
    def classvar1()
        @@classvar +=1
        puts "no of values #@@classvar"
    end    
    puts "outside all functions #@@classvar"
end

obj1=Test.new("1","krishan","hodal")
obj2=Test.new("2","mohit","palwal")
obj1.details()
obj1.classvar1()
obj2.details()
obj2.classvar1()

output:--
outside all functions 0
The id is 1
Name is krishan
And the address is hodal
no of values 1
The id is 2
Name is mohit
And the address is palwal
no of values 2

* Ruby Local Variables

Local variables begin with a lowercase letter or _. The scope of a local variable ranges from class, module, def, or do to the corresponding end or from a block's opening brace to its close brace {}.

class Test
    def check()
        id=1
        name="krishan"
        puts " my id is #{id} and name is #{name}"
    end
end
a1=Test.new

a1.check()

output:--

beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
 my id is 1 and name is krishan
 
 *Ruby Constants

Constants begin with an uppercase letter. Constants defined within a class or module can be accessed from within that class or module, and those defined outside a class or module can be accessed globally.

class Test
    Age=21
    def check()
        id=1
        name="krishan"
        puts " my id is #{id} and name is #{name} and my age is #{Age}"
    end
end
a1=Test.new

a1.check()

output:--

beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
 my id is 1 and name is krishan and my age is 21
 
 
 *Ruby Pseudo-Variables

They are special variables that have the appearance of local variables but behave like constants. You cannot assign any value to these variables.

    self − The receiver object of the current method.

    true − Value representing true.

    false − Value representing false.

    nil − Value representing undefined.

    __FILE__ − The name of the current source file.

    __LINE__ − The current line number in the source file.

**Ruby if...else Statement

x=1
if x>2
    puts "X is greater then 2"
elsif x<=1 and x!=0
    puts "x is 1"   
else 
    puts "can't find the number"
end        

*Ruby if modifier
Syntax

code if condition

$a=10
print "hello\n" if $a

output:--
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
hello

* uless statement and modifier:--

Ruby provides a special statement which is referred as unless statement. This statement is executed when the given condition is false. It is opposite of if statement. In if statement, the block executes once the given condition is true, however in unless statement, the block of code executes once the given condition is false.

x=10
unless x>=15
    puts" x is less then 15"
else 
    puts "x is greater then 15"    
end    

output:--

beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
 x is less then 15
 
 unless modifier:-- unless works when condition is false .
 
 $var =  1
print "1 -- Value is set\n" if $var
print "2 -- Value is set\n" unless $var

$var = false
print "3 -- Value is set\n" unless $var

output:--

beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
1 -- Value is set
3 -- Value is set

** Ruby case Statement
Syntax

case expression
[when expression [, expression ...] [then]
   code ]...
[else
   code ]
end

$today=8
case $today
when 0 .. 2
    puts "baby"
when 3 .. 6
    puts "little child" 
when 7..9
    puts"child"
else 
    puts "adult"
end    
    
    output:--
    beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
child


**Ruby while Statement
Syntax

while conditional [do]
   code
end

Executes code while conditional is true. A while loop's conditional is separated from code by the reserved word do, a newline, backslash \, or a semicolon ;.
Example:-
$i=0
$check=5
while $i <= $check do
    puts "Inside loop value of i is =#$i"
    $i +=1
end

output:--
Inside loop value of i is =0
Inside loop value of i is =1
Inside loop value of i is =2
Inside loop value of i is =3
Inside loop value of i is =4
Inside loop value of i is =5

** ruby while modifier:--

$i=0
$check=5
begin
    puts "Inside loop value of i is =#$i"
    $i +=1
end while $i<$check

output:-

Inside loop value of i is =0
Inside loop value of i is =1
Inside loop value of i is =2
Inside loop value of i is =3
Inside loop value of i is =4

*Ruby until Statement

until conditional [do]
   code
end

Executes code while conditional is false. An until statement's conditional is separated from code by the reserved word do, a newline, or a semicolon.

$i=0
$check=5
until $i >= $check do
    puts "Inside loop value of i is =#$i"
    $i +=1
end

output:-
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
Inside loop value of i is =0
Inside loop value of i is =1
Inside loop value of i is =2
Inside loop value of i is =3
Inside loop value of i is =4

*Ruby until modifier
Syntax

code until conditional

OR

begin
   code
end until conditional

Executes code while conditional is false.

If an until modifier follows a begin statement with no rescue or ensure clauses, code is executed once before conditional is evaluated.
Example:-

$i=0
$check=5
begin
    puts "Inside loop value of i is =#$i"
    $i +=1
end until $i >  $check

outpit:--
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
Inside loop value of i is =0
Inside loop value of i is =1
Inside loop value of i is =2
Inside loop value of i is =3
Inside loop value of i is =4
Inside loop value of i is =5

*Ruby for Statement
Syntax

for variable [, variable ...] in expression [do]
   code
end

Executes code once for each element in expression.
Example:-
for i in 1..5
    puts "here i is #{i}"
end    
output:--
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
here i is 1
here i is 2
here i is 3
here i is 4
here i is 5

* ruby each statement:-
(0..5).each do |i|
    puts "here i is #{i}"
end    
output:-
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
here i is 0
here i is 1
here i is 2
here i is 3
here i is 4
here i is 5

*Ruby break Statement
Syntax

break

Terminates the most internal loop. Terminates a method with an associated block if called within the block (with the method returning nil).
Example:-

for i in (0..5)
    if i>=2 then
        break
    end
    puts "here i is #{i}"
end        

output:--
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
here i is 0
here i is 1

*Ruby next Statement
Syntax

next

Jumps to the next iteration of the most internal loop. Terminates execution of a block if called within a block (with yield or call returning nil).
Example:-

for i in (0..5)
    if i<2 then
        next
    end
    puts "here i is #{i}"
end        

output:=
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
here i is 2
here i is 3
here i is 4
here i is 5

* redo statement
for i in (0..5)
    if i<=2 then
        puts "here i is #{i}"
        redo
    end
    
end        
output:--
here i is 0
here i is 0
here i is 0
here i is 0
-----------


*Ruby retry Statement
Syntax

retry

If retry appears in rescue clause of begin expression, restart from the beginning of the begin body.

begin
   do_something # exception raised
rescue
   # handles error
   retry  # restart from beginning
end
example:--

for i in 0..5
   retry if i > 2
puts "Value of local variable is #{i}"
end

This will produce the following result and will go in an infinite loop −
output:--
Value of local variable is 1
Value of local variable is 2
Value of local variable is 1
Value of local variable is 2
Value of local variable is 1
Value of local variable is 2
............................


                                                  ----------> Methods <-----------
                                                  
Ruby methods are very similar to functions in any other programming language. Ruby methods are used to bundle one or more repeatable statements into a single unit.

Method names should begin with a lowercase letter. If you begin a method name with an uppercase letter, Ruby might think that it is a constant and hence can parse the call incorrectly.

Methods should be defined before calling them, otherwise Ruby will raise an exception for undefined method invoking.
Syntax


So, you can define a simple method as follows −

def method_name 
   expr..
end
 
You can represent a method that accepts parameters like this −

def method_name (var1, var2)
   expr..
end

You can set default values for the parameters, which will be used if method is called without passing the required parameters −

def method_name (var1 = value1, var2 = value2)
   expr..
end

Whenever you call the simple method, you write only the method name as follows −

method_name



However, when you call a method with parameters, you write the method name along with the parameters, such as −

method_name 25, 30

Examples:---
1.
def krishan
    puts "hi everyone my name is krishan"
end    
krishan

output:-
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
hi everyone my name is krishan

 2.
 def krishan(surname)
    puts "hi everyone my name is krishan #{surname}"
end    
krishan("sorout")   

output:-
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
hi everyone my name is krishan sorout

3.
def krishan(surname="singh")
    puts "hi everyone my name is krishan #{surname}"
end    
krishan()
krishan("sorout")

output:--
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
hi everyone my name is krishan singh
hi everyone my name is krishan sorout

3.with return statement:-

def test
    i = 100
    j = 200
    k = 300
    return i, j, k
end
var = test
puts var
output:--
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
100
200
300

4.Variable Number of Parameters

Suppose you declare a method that takes two parameters, whenever you call this method, you need to pass two parameters along with it.

However, Ruby allows you to declare methods that work with a variable number of parameters. Let us examine a sample of this −
                                              
def krishan(*test)
    puts "number of parameters available is #{test.length}"
    for i in (0..test.length-1)
        puts "parameters is #{test[i]}"
    end    
end
krishan("krishan","mohit","ajay")    

output:--
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
number of parameters available is 3
parameters is krishan
parameters is mohit
parameters is ajay
                      
** Class Methods

When a method is defined outside of the class definition, the method is marked as private by default. On the other hand, the methods defined in the class definition are marked as public by default. The default visibility and the private mark of the methods can be changed by public or private of the Module.

Whenever you want to access a method of a class, you first need to instantiate the class. Then, using the object, you can access any member of the class.

Ruby gives you a way to access a method without instantiating a class. Let us see how a class method is declared and accessed −

class Accounts
   def reading_charge
   end
   def Accounts.return_date
   end
end

See how the method return_date is declared. It is declared with the class name followed by a period, which is followed by the name of the method. You can access this class method directly as follows −

=> Accounts.return_date

To access this method, you need not create objects of the class Accounts.
                        
                        example:--
class Krishan
    def Krishan.func
        puts "we don't need object for calling this function"
    end    
  
end    
Krishan.func

output:--
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
we don't need object for calling this function

*** blocks in ruby:-


    A block consists of chunks of code.

    You assign a name to a block.

    The code in the block is always enclosed within braces ({}).

A block is always invoked from a function with the same name as that of the block. This means that if you have a block with the name test,    then you use the function test to invoke this block.

You invoke a block by using the yield statement.


*The yield Statement

Let's look at an example of the yield statement −
without parameters:-
def test
    puts "hii this is method test"
    yield 
    puts "this is again method"
    yield
end 
test {puts "this is block it print 2 times"}    
output:-
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
hii this is method test
this is block it print 2 times
this is again method
this is block it print 2 times

with parameters:-

def test
    puts "hii this is method test"
    yield 1
    puts "this is again method"
    yield 2
    yield 3
    yield 4
end 
test {|i| puts "this is block it print #{i} time"}    

output:--
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
hii this is method test
this is block it print 1 time
this is again method
this is block it print 2 time
this is block it print 3 time
this is block it print 4 time

with multiple parameters :-
def test
    puts "hii this is method test"
    yield 1,2
    puts "this is again method"
    
end 
test {|a,b| puts "this is #{a+b}"}    
output:-
def test
    puts "hii this is method test"
    yield 1,2
    puts "this is again method"
    
end 
test {|a,b| puts "this is #{a+b}"}    

**Blocks and Methods:-

def test(&block)
block.call
    
end

test {puts "this is block code"}    
output:--
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
this is block code

BEGIN and END Blocks

Every Ruby source file can declare blocks of code to be run as the file is being loaded (the BEGIN blocks) and after the program has finished executing (the END blocks).


BEGIN { 
    
    puts "BEGIN code block"
 } 
 
 END { 
    
    puts "END code block"
 }
    
 puts "MAIN code block"
 
 output:--
 beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
BEGIN code block
MAIN code block
END code block

** Modules in ruby:--

Modules are a way of grouping together methods, classes, and constants. Modules give you two major benefits.

    Modules provide a namespace and prevent name clashes.

    Modules implement the mixin facility.

Modules define a namespace, a sandbox in which your methods and constants can play without having to worry about being stepped on by other methods and constants.
Syntax

module Identifier
   statement1
   statement2
   ...........
end

file name = test.rb

module Testmodule
    Good="very good"
    def Testmodule.func(x)
       puts "hii my name is #{x} and i am #{Good} in ruby ."
    end
end   

now try to access the module in new file 
check.rb:-

require './test'

Testmodule.func("krishan")

0utput:-

beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby check.rb
hii my name is krishan and i am very good in ruby .






*** string in ruby:--

A String object in Ruby holds and manipulates an arbitrary sequence of one or more bytes, typically representing characters that represent human language.

The simplest string literals are enclosed in single quotes (the apostrophe character). The text within the quote marks is the value of the string −

'This is a simple Ruby string literal'

If you need to place an apostrophe within a single-quoted string literal, precede it with a backslash, so that the Ruby interpreter does not think that it terminates the string −

'Won\'t you read O\'Reilly\'s book?'

The backslash also works to escape another backslash, so that the second backslash is not itself interpreted as an escape character.

*Expression Substitution

Expression substitution is a means of embedding the value of any Ruby expression into a string using #{ and } −

x, y, z = 12, 36, 72
puts "The value of x is #{ x }."
puts "The sum of x and y is #{ x + y }."
puts "The average was #{ (x + y + z)/3 }."

output:--
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
The value of x is 12.
The sum of x and y is 48.
The average was 40.



** string methods:--

1. sub and sub! :-

* sub:- Returns a copy of self with only the first occurrence (not all occurrences) of the given pattern replaced.
example:-

s='krishan'
puts s.sub('kri','abc')

puts s
output:--
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
abcshan
krishan
====> it does not change our original string just make changes in the copy of our string.

s='krishan'
puts s.sub(/han/,'o')

output:--
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
kriso

s='krishan'
puts s.sub('an','o')

output:--   beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
            krisho
            
s='krishan'
puts s.sub(/[aeiou]/,'o')

output:--
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
kroshan

* sub! :-- Returns self with only the first occurrence (not all occurrences) of the given pattern replaced.

examples:-

s='krishan'
puts s.sub!('kri','abc')

puts s

output:--
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
abcshan
abcshan

===> sub! makes changes in original string not in the copy of string.


2. gsub and gsub! :--

* gusb:--Returns a copy of self with all occurrences of the given pattern replaced.

examples:--
s='my name is krishan'
puts s.gsub('a','*')

puts s

output:--
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
my n*me is krish*n
my name is krishan

* gusb! :-Performs the specified substring replacement(s) on self; returns self if any replacement occurred, nil otherwise.it makes changes in original string not in copy of str.
examples:--

s='my name is krishan'
puts s.gsub!('a','*')

puts s

output:-
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
my n*me is krish*n
my n*me is krish*n

2. succ and succ! /next ,next! it is alias of succ and succ!:-- 

* succ:--Returns the successor to self. The successor is calculated by incrementing characters.

The first character to be incremented is the rightmost alphanumeric: or, if no alphanumerics, the rightmost character:-

examples:--
s='12345'
puts s.succ
output:--
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
12346

s='12345abc'
puts s.succ
output:-
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
12345abd

3.0.0 :015 > s
 => "\xFF\xFF\xFF" 
3.0.0 :016 > s.succ
 => "\x01\x00\x00\x00" 

3.0.0 :017 > s="123abc"
 => "123abc" 
3.0.0 :018 > s.succ
 => "123abd" 
3.0.0 :019 > s
 => "123abc" 

it makes changes in a copy string not in original string


*succ!:-- it makes chnges in original string :-

example:--

3.0.0 :019 > s
 => "123abc" 
3.0.0 :020 > s.succ!
 => "123abd" 
3.0.0 :021 > s
 => "123abd" 
3.0.0 :022 > 

3. replace :--Replaces the contents of self with the contents of other_string:

3.0.0 :026 > s
 => "123abe" 
3.0.0 :027 > s.replace('krishan')
 => "krishan" 
3.0.0 :028 > s
 => "krishan" 
3.0.0 :029 > 

a="my name is krishan"
puts a.replace('krishan')
puts a

output:--

beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
krishan
krishan

4. reverse and reverse!:- it reverse the string but only copy of string not original string:-

reverse:-

a="krishan"
puts a.reverse

puts a

output:--

beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
nahsirk
krishan

* reverse!:-it also reverse the original string:-
a="krishan"
puts a.reverse!

puts a
output:--
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
nahsirk
nahsirk

5. setbyte :-Sets the byte at zero-based index to integer; returns integer:

a="abcde"
puts a.setbyte(0,99)

puts a

output:--

beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
99
cbcde


a="abcde"
puts a.setbyte(0,98)

puts a

output:--

beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
98
bbcde

6. tr(from_str, to_str) => new_str

Returns a copy of str with the characters in from_str replaced by the corresponding characters in to_str. If to_str is shorter than from_str, it is padded with its last character in order to maintain the correspondence.

3.0.0 :029 > s="krishan"
 => "krishan" 
3.0.0 :030 > s.tr('han','123')
 => "kris123" 
3.0.0 :031 > s.tr('han','12345')   it only changes number of characters available in 1st string
 => "kris123" 
3.0.0 :032 > s
 => "krishan" 
3.0.0 :033 > s.tr('han','12345')
 => "kris123" 
3.0.0 :034 > s.tr('krishan','12')  it prints last character if 2nd string ot to string is short then from 
 => "1222222" 
3.0.0 :035 > s
 => "krishan" 


* tr!:-- Translates str in place, using the same rules as String#tr. Returns str, or nil if no changes were made.

a='krishan'
puts a.tr!('kri','abc')   makes parment change in string
puts a

output:--

beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
abcshan
abcshan

7. tr_s :--Processes a copy of str as described in String#tr, then removes duplicate characters in regions that were affected by the translation.

a="hello"
puts a.tr_s('el','*')
puts a

output:--

beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
h*o
hello

* tr_s!:--Performs String#tr_s processing on str in place, returning str, or nil if no changes were made.


a="hello"
puts a.tr_s!('el','*')     it makes changes in original string
puts a

output:--
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
h*o
h*o

8. new string:-- 
  With no arguments, returns the empty string with the Encoding ASCII-8BIT:

3.0.0 :052 > s=String.new
 => "" 
3.0.0 :053 > s.encoding
 => #<Encoding:ASCII-8BIT>
 
 With the single String argument string, returns a copy of string with the same encoding as string:
  
3.0.0 :054 > s=String.new("krishan")
 => "krishan" 
3.0.0 :055 > s.encoding
 => #<Encoding:UTF-8> 

With keyword encoding, returns a copy of str with the specified encoding:

3.0.0 :061 > a=String.new(encoding: 'ASCII')
 => "" 
3.0.0 :062 > a.encoding
 => #<Encoding:US-ASCII> 

3.0.0 :063 > a=String.new('krishan',encoding:'ASCII')
 => "krishan" 
3.0.0 :064 > a.encoding
 => #<Encoding:US-ASCII> 


With keyword capacity, returns a copy of str; the given capacity may set the size of the internal buffer, which may affect performance:

3.0.0 :071 > a=String.new(capacity:1)
 => "" 
3.0.0 :072 > a=String.new(capacity:4096)
 => "" 
3.0.0 :073 > 

The string, encoding, and capacity arguments may all be used together:

3.0.0 :073 > a=String.new('hello',encoding:'UTF-8',capacity:25)
 => "hello" 
3.0.0 :074 > 

9. try_convert(object) → object, new_string, or nil

If object is a String object, returns object.

Otherwise if object responds to :to_str, calls object.to_str and returns the result.

Returns nil if object does not respond to :to_str.

Raises an exception unless object.to_str returns a String object.

10.   string * integer → new_string 

Returns a new String containing integer copies of self:

example :-
3.0.0 :080 > "krishan " * 3
 => "krishan krishan krishan " 

3.0.0 :083 > a="hello "
 => "hello " 
3.0.0 :084 > a * 3
 => "hello hello hello " 

11. string + other_string → new_string

Returns a new String containing other_string concatenated to self:

example:-
3.0.0 :089 > a="krishan "
 => "krishan " 
3.0.0 :090 > b="sorout"
 => "sorout" 
3.0.0 :091 > a
 => "krishan " 
3.0.0 :092 > b
 => "sorout" 
3.0.0 :093 > a + b
 => "krishan sorout" 
3.0.0 :094 > 

12. +string → new_string or self 

Returns self if self is not frozen.

Otherwise. returns self.dup, which is not frozen.

example:-
3.0.0 :095 > + "krishan"
 => "krishan" 

13. -string → frozen_string

Returns a frozen, possibly pre-existing copy of the string.

The returned String will be deduplicated as long as it does not have any instance variables set on it.

14.  string << object → string

Concatenates object to self and returns self:
example:--
3.0.0 :104"> a="krishan "
 => "krishan " 
3.0.0 :105 > a << "sorout"
 => "krishan sorout" 

14.  string <=> other_string → -1, 0, 1, or nil

Compares self and other_string, returning:

    -1 if other_string is larger.

    0 if the two are equal.

    1 if other_string is smaller.

    nil if the two are incomparable.

Examples:
3.0.0 :110 > "krishan" <=> "krishan"
 => 0 
3.0.0 :111 > "krishan" <=> "krishan sorout"
 => -1 
3.0.0 :112 > "krishan" <=> "kris"
 => 1 
3.0.0 :113 > "krishan" <=> 123
 => nil 
3.0.0 :114 > 


15. string == object → true or false 

Returns true if object has the same length and content; as self; false otherwise:

example:--

3.0.0 :114 > s="foo"
 => "foo" 
3.0.0 :115 > s == "foo"
 => true 
3.0.0 :116 > s == "fooe"
 => false 
3.0.0 :117 > s == 123
 => false 

16.   string =~ regexp → integer or nil
string =~ object → integer or nil

Returns the Integer index of the first substring that matches the given regexp, or nil if no match found:
examples:--
3.0.0 :119 > "foo" =~ /f/
 => 0 
3.0.0 :120 > "foo" =~ /o/
 => 1 
3.0.0 :121 > "foo" =~ /oo/
 => 1 
3.0.0 :122 > "food" =~ /d/
 => 3 
3.0.0 :123 > "food" =~ /x/
 => nil 

17.  string[index] → new_string or nil
string[start, length] → new_string or nil
string[range] → new_string or nil
string[regexp, capture = 0] → new_string or nil
string[substring] → new_string or nil 

examples:--
When the single Integer argument index is given, returns the 1-character substring found in self at offset index:

3.0.0 :126 > "krishan"[1]
 => "r" 
3.0.0 :127 > "krishan"[5]
 => "a" 
3.0.0 :128 > a="krishan"
 => "krishan" 
3.0.0 :129 > a[5]
 => "a" 

Counts backward from the end of self if index is negative:
3.0.0 :128 > a="krishan"
 => "krishan" 

3.0.0 :130 > a[-1]
 => "n" 
3.0.0 :131 > a[-2]
 => "a" 

Returns nil if index is out of range:
3.0.0 :132 > a[8]
 => nil 

When the two Integer arguments start and length are given, returns the substring of the given length found in self at offset start:
3.0.0 :133 > a[0,3]
 => "kri" 
 
 Counts backward from the end of self if start is negative:
 3.0.0 :134 > a[-2,2]
 => "an" 
3.0.0 :135 > a[-3,2]
 => "ha" 
3.0.0 :136 > a[-3,3]
 => "han"
 
 Special case: returns a new empty String if start is equal to the length of self:
 3.0.0 :139 > a[7,2]
 => "" 

18.  ascii_only? → true or false 

Returns true for a string which has only ASCII characters.

examples:-
3.0.0 :141 > "abc".force_encoding("UTF-8").ascii_only?
 => true 
3.0.0 :142 > "abc\u{6666}".force_encoding("UTF-8").ascii_only?
 => false 

19.  bytesize → integer

Returns the count of bytes in self:

example:--
3.0.0 :149 > b
 => "sorout" 
3.0.0 :150 > b.bytesize
 => 6 

20.  byteslice(index, length = 1) → string or nil
byteslice(range) → string or nil 

examples:--

3.0.0 :157 > s='123456789'
 => "123456789" 
3.0.0 :158 > s.byteslice(4)
 => "5" 
3.0.0 :159 > s.byteslice(2,5)
 => "34567" 
3.0.0 :160 > s.byteslice(2,50)
 => "3456789" 


21.  capitalize(*options) → self or nil

Returns a string containing the characters in self; the first character is upcased; the remaining characters are downcased:
only make changes in a copy string not in original string.
examples:--

s="hello world"
puts s.capitalize 
puts s

output:--

beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
Hello world
hello world

** capitalize! :-- makes changes in original string also:-

s="hello world"
puts s.capitalize! 
puts s

output:-
beryl@beryl-HP-ProBook-6460b:~/Desktop/RubyPractical$ ruby test.rb
Hello world
Hello world

22.  casecmp(other_string) → -1, 0, 1, or nil

Compares self.downcase and other_string.downcase; returns:

    -1 if other_string.downcase is larger.

    0 if the two are equal.

    1 if other_string.downcase is smaller.

    nil if the two are incomparable.

Examples:
3.0.0 :165 > 'foo'.casecmp('foo')
 => 0 
3.0.0 :166 > 'foo'.casecmp('food')
 => -1 
3.0.0 :167 > 'foo'.casecmp('fo')
 => 1 
3.0.0 :168 > 'foo'.casecmp(1)
 => nil 

23.  casecmp?(other_string) → true, false, or nil 

Returns true if self and other_string are equal after Unicode case folding, otherwise false

examples:-

3.0.0 :170 > 'foo'.casecmp?('foo')
 => true 
3.0.0 :171 > 'foo'.casecmp?('food')
 => false 
3.0.0 :172 > 'foo'.casecmp?(1)
 => nil 

24. center(width, padstr=' ') → new_str 

Centers str in width. If width is greater than the length of str, returns a new String of length width with str centered and padded with padstr; otherwise, returns str.

examples:-
3.0.0 :174 > "krishan".center(6)
 => "krishan" 
3.0.0 :175 > "krishan".center(8)
 => "krishan " 
3.0.0 :176 > "krishan".center(18)
 => "     krishan      " 
3.0.0 :177 > "krishan".center(10)
 => " krishan  " 
3.0.0 :178 > "krishan".center(11)
 => "  krishan  " 
3.0.0 :179 > "krishan".center(11,'123')
 => "12krishan12" 
3.0.0 :180 > "krishan".center(21,'123')
 => "1231231krishan1231231" 
 
 25.  chomp(separator=$/) → new_str

Returns a new String with the given record separator removed from the end of str (if present). If $/ has not been changed from the default Ruby record separator, then chomp also removes carriage return characters (that is, it will remove \n, \r, and \r\n). If $/ is an empty string, it will remove all trailing newlines from the string.

examples:--

3.0.0 :201 > a="hello"
 => "hello" 
3.0.0 :202 > a.chomp
 => "hello" 
 
 3.0.0 :203 > a="hello\n"
 => "hello\n" 
3.0.0 :204 > a
 => "hello\n" 
3.0.0 :205 > a.chomp
 => "hello" 
3.0.0 :206 > a
 => "hello\n" 

3.0.0 :206 > a
 => "hello\n" 
3.0.0 :207 > a.chomp("\n")
 => "hello" 
3.0.0 :208 > a         it does not make changes in original string it makes changes in a copy of that string.
 => "hello\n" 

***chomp! :- it makes changes in original string: -
3.0.0 :209 > a
 => "hello\n" 
3.0.0 :210 > a.chomp!("\n")
 => "hello" 
3.0.0 :211 > a
 => "hello" 

3.0.0 :212 > a="krishan"
 => "krishan" 

3.0.0 :214 > a.chomp!('shan')
 => "kri" 
3.0.0 :215 > a
 => "kri" 


26. chars → an_array 

Returns an array of characters in str. This is a shorthand for str.each_char.to_a.

If a block is given, which is a deprecated form, works the same as each_char.

example:--

3.0.0 :219 > a="krishan sorout"
 => "krishan sorout" 
 
3.0.0 :220 > a.chars
 => ["k", "r", "i", "s", "h", "a", "n", " ", "s", "o", "r", "o", "u", "t"] 


27.  chop → new_str

Returns a new String with the last character removed. If the string ends with \r\n, both characters are removed. Applying chop to an empty string returns an empty string. String#chomp is often a safer alternative, as it leaves the string unchanged if it doesn't end in a record separator.

examples:--
3.0.0 :225 > a="hello"
 => "hello" 
3.0.0 :226 > a.chop
 => "hell" 

3.0.0 :227 > a="hello\n\r"
 => "hello\n\r" 
3.0.0 :228 > a.chop
 => "hello\n" 
 
 3.0.0 :230 > a="hello\r\n"
 => "hello\r\n" 
3.0.0 :231 > a.chop
 => "hello"
 
 
 * chop! :- makes changes in original string.
 
 example:-
 3.0.0 :232 > a="hello"
 => "hello" 

3.0.0 :234 > a.chop!
 => "hell" 
3.0.0 :235 > a
 => "hell" 

28.  chr → string click to toggle source

Returns a string containing the first character of self:-

example:-

3.0.0 :236 > s="krishan"
 => "krishan" 
3.0.0 :237 > s.chr
 => "k" 

29.  clear → self

Removes the contents of self:

example:--

3.0.0 :238 > s
 => "krishan" 
3.0.0 :239 > s.clear
 => "" 
3.0.0 :240 > s
 => "" 

30.  codepoints → an_array

Returns an array of the Integer ordinals of the characters in str. This is a shorthand for str.each_codepoint.to_a.

If a block is given, which is a deprecated form, works the same as each_codepoint

examples:-

3.0.0 :242 > a="hello"
 => "hello" 
3.0.0 :243 > a.codepoints
 => [104, 101, 108, 108, 111] 

31.  concat(*objects) → string 

Concatenates each object in objects to self and returns self:

examples:--

3.0.0 :244 > s="foo"
 => "foo" 
3.0.0 :245 > s.concat('ok','concated')
 => "foookconcated" 
3.0.0 :246 > s
 => "foookconcated" 
3.0.0 :247 > s.concat(12,'this',15,'or')
 => "foookconcated\fthis\u000For" 
3.0.0 :248 > s
 => "foookconcated\fthis\u000For" 
3.0.0 :249 > a="krishan"
 => "krishan" 
3.0.0 :250 > a.concat(32,'sorout')
 => "krishan sorout" 

32.   delete([other_str]+) → new_str 

Returns a copy of str with all characters in the intersection of its arguments deleted. Uses the same rules for building the set of characters as String#count.

examples:-

3.0.0 :268 > a.delete("h")
 => "ello" 
3.0.0 :269 > a.delete("l")
 => "heo" 
3.0.0 :270 > a
 => "hello" 

3.0.0 :271 > a="my name is krishan"
 => "my name is krishan" 
 
3.0.0 :272 > a.delete "my name is"
 => "krh" 

3.0.0 :273 > a="my name is krishan my name is"
 => "my name is krishan my name is" 

3.0.0 :274 > a.delete "my name is"
 => "krh" 


* delete!:- delete from original string or make changes in original string not in copy of string, 

example:=
3.0.0 :277 > a
 => "hello india" 
3.0.0 :278 > a.delete! "india"
 => "hello " 
3.0.0 :279 > a
 => "hello " 

33.  delete_prefix(prefix) → new_str

Returns a copy of str with leading prefix deleted.

examples:-it only delete prefix values not sufix values;

3.0.0 :280 > a
 => "hello " 
3.0.0 :281 > a.delete_prefix("hel")
 => "lo " 
3.0.0 :282 > a.delete_prefix("llo")
 => "hello " 


** delete_prefix! :-- it makes changes in original string delete string permanentely:-

example:--
3.0.0 :286 > a
 => "hello world" 

3.0.0 :288 > a
 => "hello world" 
 
3.0.0 :289 > a.delete_prefix!("hello")
 => " world"
  
3.0.0 :290 > a
 => " world" 

34. delete_suffix(suffix) → new_str 

Returns a copy of str with trailing suffix deleted.it only delete suffix values not prefix values.and makes changes in a copy string not in original string.


3.0.0 :290 > a
 => " world" 
3.0.0 :291 > a="hello world"
 => "hello world" 
3.0.0 :292 > a.delete_suffix("world")
 => "hello " 
3.0.0 :293 > a
 => "hello world" 
3.0.0 :294 > a.delete_suffix("hello")
 => "hello world" 


** delete_suffix! :-- it makes changes in original string.

examples:-

3.0.0 :295 > a
 => "hello world" 
 
3.0.0 :296 > a.delete_suffix!("world")
 => "hello " 

3.0.0 :297 > a
 => "hello " 

35. downcase(*options) → string

Returns a string containing the downcased characters in self:
examples:-
3.0.0 :298 > a="Hello"
 => "Hello" 
3.0.0 :299 > a.downcase
 => "hello" 
3.0.0 :300 > a
 => "Hello" 
3.0.0 :301 > a="HELLO"
 => "HELLO" 
3.0.0 :302 > a.downcase
 => "hello" 

** downcase! :- it makes changes in original string:

examples:-

3.0.0 :303 > a
 => "HELLO" 
3.0.0 :304 > a.downcase!
 => "hello" 
3.0.0 :305 > a
 => "hello" 
 
 36. dump → string

Returns a printable version of self, enclosed in double-quotes, with special characters escaped, and with non-printing characters replaced by hexadecimal notation:

examples:--

3.0.0 :009 > a="hello"
 => "hello" 
3.0.0 :010 > a.dump
 => "\"hello\"" 
3.0.0 :011 > a="hello \n"
 => "hello \n" 
3.0.0 :012 > a.dump
 => "\"hello \\n\"" 
3.0.0 :013 > a
 => "hello \n" 


37. each_byte {|integer| block } → str
each_byte → an_enumerator

Passes each byte in str to the given block, or returns an enumerator if no block is given.
examples:-

3.0.0 :016 > a.each_byte
 => #<Enumerator: "hello":each_byte> 
 
3.0.0 :017 > a.each_byte {|c| print c ," "}
104 101 108 108 111  => "hello" 

3.0.0 :018 > a
 => "hello" 

38. each_char {|cstr| block } → str
each_char → an_enumerator

Passes each character in str to the given block, or returns an enumerator if no block is given.

examples:--
3.0.0 :018 > a
 => "hello" 

3.0.0 :019 > a.each_char {|c| print c ," "}
h e l l o  => "hello" 

3.0.0 :020 > a.each_char {|c| print c }
hello => "hello" 

 
3.0.0 :021 > a.each_char 
 => #<Enumerator: "hello":each_char>
 
 39.  each_codepoint {|integer| block } → str 
each_codepoint → an_enumerator

Passes the Integer ordinal of each character in str, also known as a codepoint when applied to Unicode strings to the given block. For encodings other than UTF-8/UTF-16(BE|LE)/UTF-32(BE|LE), values are directly derived from the binary representation of each character.

If no block is given, an enumerator is returned instead.

examples:--
3.0.0 :023 > a.each_codepoint {|a| print a ," "}
104 101 108 108 111  => "hello" 
3.0.0 :024 > 
3.0.0 :025 > a.each_codepoint
 => #<Enumerator: "hello":each_codepoint> 

40.  each_grapheme_cluster {|cstr| block } → str click to toggle source
     each_grapheme_cluster → an_enumerator

Passes each grapheme cluster in str to the given block, or returns an enumerator if no block is given. Unlike String#each_char, this enumerates by grapheme clusters defined by Unicode Standard Annex #29 unicode.org/reports/tr29/

examples:--
3.0.0 :026 > a
 => "hello" 
3.0.0 :027 > a.each_grapheme_cluster {|a| print a, " "}
h e l l o  => "hello" 

3.0.0 :028 > a.each_grapheme_cluster.to_a.size
 => 5 

41. each_line(separator=$/, chomp: false) {|substr| block } → str
each_line(separator=$/, chomp: false) → an_enumerator

Splits str using the supplied parameter as the record separator ($/ by default), passing each substring in turn to the supplied block. If a zero-length record separator is supplied, the string is split into paragraphs delimited by multiple successive newlines.

If chomp is true, separator will be removed from the end of each line.

If no block is given, an enumerator is returned instead.

examples:--

3.0.0 :034 > a="hello\nworld"
 => "hello\nworld" 
 
3.0.0 :035 > a.each_line {|s| print s}
hello
world => "hello\nworld" 

3.0.0 :037 > a
 => "hello\nworld" 
3.0.0 :038 > a.each_line('l') {|s| p s}
"hel"
"l"
"o\nworl"
"d"
 => "hello\nworld" 


42.  empty? → true or false 

Returns true if the length of self is zero, false otherwise:

examples:--

3.0.0 :040 > a="hello"
 => "hello" 
3.0.0 :041 > a.empty?
 => false 
3.0.0 :042"> a=""
 => "" 
3.0.0 :043 > a.empty?
 => true 

43.  encoding → encoding

Returns the Encoding object that represents the encoding of obj.
examples:--

3.0.0 :054 > a="hello"
 => "hello" 
3.0.0 :055 > a.encoding
 => #<Encoding:UTF-8> 

44. end_with?([suffixes]+) → true or false

Returns true if str ends with one of the suffixes given.

examples:-
3.0.0 :056 > a="hello world"
 => "hello world" 
3.0.0 :057 > a.end_with?("world")
 => true 
3.0.0 :058 > a.end_with?("ld")
 => true 
3.0.0 :059 > a.end_with?("worl")
 => false 
3.0.0 :060 > a.end_with?("hello")
 => false 

3.0.0 :062 > a
 => "hello world" 
3.0.0 :063 > a.end_with?('abc','ld')
 => true 
3.0.0 :064 > a.end_with?('abc','labc')
 => false 

